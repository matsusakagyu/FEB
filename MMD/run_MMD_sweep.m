function run_MMD_sweep(rhoL_vec, rhoT_vec, opts)
% run_MMD_sweep — calls main_MMD for a sweep of wheelbase (L) & track (t) ratios.
% Works with vehicle_params() that use either fields tf/tr OR tfw/trw.
%
% Examples:
%   run_MMD_sweep([0.8 1.0 1.2], [0.9 1.0 1.1])
%   run_MMD_sweep([0.85 0.95 1.05 1.15], 1.0, struct('mode','hold_t_over_L'))

% ---- defaults ----
if nargin < 1, rhoL_vec = 1.0; end
if nargin < 2, rhoT_vec = 1.0; end
if nargin < 3, opts = struct; end
opts = setdef(opts, 'mode', 'independent');     % or 'hold_t_over_L'
opts = setdef(opts, 'pause_s', 0.2);
opts = setdef(opts, 'linkfigs', false);
opts = setdef(opts, 'tagPrefix', 'MMD');

% ensure row vectors
if isscalar(rhoL_vec), rhoL_vec = rhoL_vec(:)'; end
if isscalar(rhoT_vec), rhoT_vec = rhoT_vec(:)'; end

% ---- locate and back up vehicle_params.m ----
thisDir = fileparts(mfilename('fullpath'));
vpFile  = fullfile(thisDir, 'vehicle_params.m');
backup  = fullfile(thisDir, 'vehicle_params__backup_autosweep__.m');
assert(exist(vpFile,'file')==2, 'vehicle_params.m not found in %s', thisDir);

% baseline struct
p0 = vehicle_params();

% resolve field names for tracks present in p0
has_tf  = isfield(p0,'tf');   has_tr  = isfield(p0,'tr');
has_tfw = isfield(p0,'tfw');  has_trw = isfield(p0,'trw');
assert((has_tf && has_tr) || (has_tfw && has_trw), ...
  'vehicle_params() must define either (tf,tr) or (tfw,trw).');

% read baseline values
L0  = getfield(p0,'lf') + getfield(p0,'lr'); %#ok<GFLD>
tF0 = has_tf  * getfield(p0,'tf')  + has_tfw * getfield(p0,'tfw');
tR0 = has_tr  * getfield(p0,'tr')  + has_trw * getfield(p0,'trw');
lf0 = getfield(p0,'lf');  lr0 = getfield(p0,'lr');

% back up original file once
if ~exist(backup,'file')
    copyfile(vpFile, backup);
end
cleanup = onCleanup(@() restore_original(vpFile, backup));

% ---- build sweep grid ----
if strcmpi(opts.mode, 'hold_t_over_L')
    % keep t/L constant → only L varies; set rhoT = rhoL internally
    grid = combvec(reshape(rhoL_vec,1,[]), 1);
    tie_t_to_L = true;
else
    grid = combvec(reshape(rhoL_vec,1,[]), reshape(rhoT_vec,1,[]));
    tie_t_to_L = false;
end

% ---- run cases ----
figs = gobjects(0);
nCases = size(grid,2);
fprintf('Running %d sweep cases...\n', nCases);

for k = 1:nCases
    rhoL = grid(1,k);
    rhoT = tie_t_to_L * rhoL + (~tie_t_to_L) * (size(grid,1)>1) * grid(2,k);
    if tie_t_to_L, rhoT = rhoL; end
    if isempty(rhoT), rhoT = 1.0; end

    % scale geometry, keep CG fraction (lf/L) constant
    L   = L0 * rhoL;
    aFr = lf0 / L0;
    lf  = aFr * L;
    lr  = L - lf;
    tf  = tF0 * rhoT;
    tr  = tR0 * rhoT;

    % write shim vehicle_params.m that returns p0 but overrides geometry
    code = make_vehicle_params_shim(p0, lf, lr, tf, tr, has_tf, has_tr, has_tfw, has_trw);
    fid = fopen(vpFile,'w');  assert(fid>0, 'Cannot open vehicle_params.m for writing');
    fwrite(fid, code); fclose(fid);

    % run your MMD
    close(findobj('Type','figure','-regexp','Name','^Moment Method Diagram')); %#ok<FNDSB>
    main_MMD;     % <- your existing script/function

    % tag figure
    fig = gcf;
    fig.Name = sprintf('%s | L/L0=%.2f, t/t0=%.2f', opts.tagPrefix, rhoL, rhoT);
    ax = gca;
    ax.Title.String = sprintf('%s — L/L_0=%.2f, t/t_0=%.2f', ax.Title.String, rhoL, rhoT);

    figs(end+1) = fig; %#ok<AGROW>
    pause(opts.pause_s);
end

% optional: link axes
if opts.linkfigs && numel(figs)>1
    axs = arrayfun(@(f) get(f,'CurrentAxes'), figs);
    linkaxes([axs{:}],'xy'); %#ok<CCAT>
end

fprintf('Sweep complete. Restoring original vehicle_params.m\n');

end

% ---------- helpers ----------
function restore_original(vpFile, backup)
if exist(backup,'file')==2
    try
        copyfile(backup, vpFile, 'f');
        delete(backup);
    catch
        % leave backup if delete fails
    end
end
end

function code = make_vehicle_params_shim(p0, lf, lr, tf, tr, has_tf, has_tr, has_tfw, has_trw)
% Emit a vehicle_params.m that reconstructs baseline p0 and overrides fields.
S = jsonencode(p0);  % R2016b+
code = sprintf([ ...
'function p = vehicle_params()\n' ...
'%% AUTO-GENERATED by run_MMD_sweep — DO NOT EDIT\n' ...
'p = jsondecode(''%s'');\n' ...
'p.lf = %.15g; p.lr = %.15g;\n' ...
'%s%s' ...  % track fields set depending on field names in baseline
'if isfield(p,''L''), p.L = p.lf + p.lr; end\n' ...
'%s' ...     % recompute static loads if present
'end\n' ...
], S, lf, lr, ...
   track_assign(tf,tr,has_tf,has_tr,has_tfw,has_trw), ...
   recompute_statics());
end

function txt = track_assign(tf,tr,has_tf,has_tr,has_tfw,has_trw)
% Generate MATLAB lines to set whichever track fields exist in baseline
lines = {};
if has_tf,   lines{end+1} = sprintf('p.tf  = %.15g;\n', tf); end
if has_tr,   lines{end+1} = sprintf('p.tr  = %.15g;\n', tr); end
if has_tfw,  lines{end+1} = sprintf('p.tfw = %.15g;\n', tf); end
if has_trw,  lines{end+1} = sprintf('p.trw = %.15g;\n', tr); end
txt = strjoin(lines, '');
end

function txt = recompute_statics()
% If your vehicle_params has Wf/Wr and g, keep them consistent after geometry change
txt = [ ...
'if isfield(p,''g'')\n' ...
'  if isfield(p,''Wf''), p.Wf = (p.lr/(p.lf+p.lr)) * p.m * p.g; end\n' ...
'  if isfield(p,''Wr''), p.Wr = (p.lf/(p.lf+p.lr)) * p.m * p.g; end\n' ...
'end\n' ];
end

function s = setdef(s, k, v)
if ~isfield(s,k) || isempty(s.(k)), s.(k) = v; end
end

